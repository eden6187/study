# 8장 경계 -> 인터페이스 분리 원칙??

## 외부 코드 사용하기

- HaspMap 예제 -> 이것도 결국엔 하나의 어댑터 아닌가?
- 사용자에게 필요하지 않은 기능까지 제공해서는 안된다.
- 프로그램에 반드시 필요한 인터페이스만 제공하려하자.
- 경계 인터페이스를 공개 API의 인수로 넘기거나 반환값으로 사용하면 안된다.
  - 즉, 경계를 확실히하라!

## 경계 살피고 익히기, log4j 익히기, 학습 테스트는 공짜 이상이다.

- 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이러한 경계 테스트가 있다면, 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전에 머무르게 될 가능성이 높다.

## 아직 존재하지 않는 코드를 사용하기

- adapter 패턴을 사용해서 API 사용을 캡슐화 한다.
- API(외부 API)가 바뀔 때 수정해야 할 부분을 명확하게 한다.

## 깨끗한 경계

- 경계에 위치하는 코드는 깔끔하게 분리한다. 또한 테스트케이스도 작성한다.
- 외부 API를 호출하는 코드와의 경계를 명확하게 하자 (Apdater 사용.)

-> 내부에서 사용하는 쪽 / 내부와 외부의 interface / 외부와 연결하는 쪽(테스트 코드 반드시 필요)
-> 3개의 역할로 분리하는 것이 어떨까??

# 9장 단위 테스트

## TDD 법칙
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

- 하지만, 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발한다.

## 깨끗한 테스트 코드 유지하기

- 테스트 코드는 실제 코드 못지않게 중요하다.
- 테스트 코드를 작성하는 이유를 생각해보자. 결국엔 **변경**이다.
- 즉, 변경에도 안전하게 대처하기 위해서 단위 테스트를 작성하는 것인데, 단위 코드가 엉망이면 될 까?
- test에서 효율 따지면 안된다고? -> fast 하게 짜라며;
- 하나의 test는 하나의 개념만 테스트해야 한다.

## FIRST

- Fast : 빠르게
- Independent : 독립적으로
- Repeateable : 반복가능하게 -> 환경에 독립적으로 짜라는 말??
- Self-Validatig : 테스트가 스스로 자기가 틀린지 맞는지 확인해야 한다. (즉, 개발자 개입 없어야 한다.)
- Timely : 나중 따위는 없다. -> 실제 코드를 짜기 직전에 test 코드를 짜자.


# 11장 클래스

## 클래스 체계

- [private method 테스트 하기](https://coding-nyan.tistory.com/105)
- private을 푸는 것은 최후의 수단!!

## 클래스는 작아야 한다!

- 클래스 이름을 지을때는 클래스의 책임을 기술해야 한다.
- 원래 만들때는 누가나 God Class로 만든다. 하지만, 이러한 큰 클래스를 더 작은 역할을 가진 클래스로 분리해야 한다.
- 응집도
  - 몇몇 메서드만이 사용하는 인스턴스 변수가 많아진다면, 새로운 클래스로 쪼개야 한다는 신호다.

-> 결국, SOLID 잘 지키고, 그 기본은 일단 책임을 잘 분리하는 것이다.

# 11장 시스템

